use rust_dbg::fasta_reader::FastaReader;
use rust_dbg::graph::Graph;
// use rust_dbg::make_histo;
use rust_dbg::path::{
    MAX_OFFSET, MAX_PATH_LENGTH, MIN_NB_REPEATS, MIN_PATH_LENGTH, MixedPath, MyExtension,
};

use debruijn::{Kmer, kmer};

use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::PathBuf;
use std::time::Instant;

use serde::{Deserialize, Serialize};

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// K-mer size
    #[arg(short)]
    k_size: usize,

    /// Path to the binary graph file
    #[arg(short, long)]
    graph: PathBuf,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a graph from a file of unitigs (as generated by ggcat)
    Build {
        /// Path to the unitigs file
        input: PathBuf,

        /// Treat reverse complementary kmers as different
        #[arg(short, long, default_value_t = false)]
        forward_only: bool,
    },
    /// Get some stats about a graph
    StatsG {},
    /// Encode a continuous sequence into a path in the graph
    Encode {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,
    },
    /// Decode a path in the graph to retrieve the original sequence
    Decode {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (reconstructed sequence in fasta format)
        #[arg(short, long)]
        output: PathBuf,
    },
    /// Get some stats about the encoding of a path
    StatsP {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,
    },
}

impl Commands {
    fn run<K: Kmer + Send + Sync + Serialize + for<'a> Deserialize<'a>>(
        &self,
        path_graph: &PathBuf,
    ) {
        match self {
            Commands::Build {
                input,
                forward_only,
            } => {
                eprint!("Creating graph (parallel)... ");
                std::io::stderr().flush().unwrap();
                let start = Instant::now();
                let graph = Graph::<K>::from_unitigs(input, *forward_only);
                let duration = start.elapsed();
                eprintln!("done in {:?}", duration);

                eprint!("Saving graph... ");
                std::io::stderr().flush().unwrap();
                let start = Instant::now();

                let f = BufWriter::new(File::create(path_graph).unwrap());
                graph.save_to_binary(Box::new(f)).unwrap();

                let duration = start.elapsed();
                eprintln!("done in {:?}", duration);
            }
            Commands::StatsG {} => {
                let graph = Graph::<K>::load_from_binary(&path_graph).unwrap();

                let mut node_length: usize = 0;
                let mut nb_edges: usize = 0;
                let mut edges_histo: [[u32; 5]; 5] = [[0; 5]; 5];

                for node in graph.iter_nodes() {
                    node_length += node.len();
                    let exts = node.exts();
                    nb_edges += (exts.num_exts_l() + exts.num_exts_r()) as usize;
                    edges_histo[exts.num_exts_l() as usize][exts.num_exts_r() as usize] += 1;
                }
                eprintln!(
                    "Graph contains:\n   - {} nodes\n   - {} edges\nAverage node length: {}",
                    graph.len(),
                    nb_edges / 2,
                    node_length / graph.len()
                );
                eprintln!("Edges histogram:");
                for i in 0..5 {
                    for j in 0..5 {
                        eprint!("{:>7} ", edges_histo[i][j]);
                    }
                    eprintln!();
                }
            }
            Commands::Encode { input, output } => {
                let graph = Graph::<K>::load_from_binary(path_graph).unwrap();
                let fasta_reader = FastaReader::new(input).unwrap();
                let mut output_writer = File::create(output).unwrap();

                // write the header
                let date = chrono::Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
                writeln!(output_writer, "DATE:\n\t{}", date).unwrap();
                let git_hash = option_env!("GIT_COMMIT_HASH").unwrap_or("unknown");
                writeln!(output_writer, "GIT VERSION:\n\t{}", git_hash).unwrap();
                let command = std::env::args().collect::<Vec<_>>().join(" ");
                writeln!(output_writer, "COMMAND:\n\t{}", command).unwrap();
                writeln!(output_writer, "CONSTANTS:").unwrap();
                writeln!(output_writer, "\tMIN_PATH_LENGTH: {}", MIN_PATH_LENGTH).unwrap();
                writeln!(output_writer, "\tMAX_PATH_LENGTH: {}", MAX_PATH_LENGTH).unwrap();
                writeln!(output_writer, "\tMIN_NB_REPEATS: {}", MIN_NB_REPEATS).unwrap();
                writeln!(output_writer, "\tMAX_OFFSET: {}", MAX_OFFSET).unwrap();

                // encode the records
                for record in fasta_reader {
                    eprintln!("Encoding record {}", record.header());
                    let path = MixedPath::encode_seq(&graph, &record.dna_string());
                    writeln!(output_writer, ">{}", record.header()).unwrap();
                    writeln!(output_writer, "{}", path).unwrap();
                }
            }
            Commands::Decode { input, output } => {
                let graph = Graph::<K>::load_from_binary(path_graph).unwrap();
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                let mut output_writer = File::create(output).unwrap();

                // go to the first '>'
                input_reader.skip_until(b'>').unwrap();
                let mut current_header = String::new();
                while input_reader.read_line(&mut current_header).unwrap() > 0 {
                    // read the path
                    let mut buffer = Vec::new();
                    input_reader.read_until(b'>', &mut buffer).unwrap();
                    if buffer.last() == Some(&b'>') {
                        buffer.pop();
                    }
                    let current_path = String::from_utf8_lossy(&buffer);

                    // proccess the path
                    eprintln!("Decoding record {}", current_header);
                    let path = MixedPath::from_string(&current_path, &graph).unwrap();
                    let seq = path.decode_seq();
                    writeln!(output_writer, ">{}", current_header).unwrap();
                    writeln!(output_writer, "{}", seq.to_string()).unwrap();
                }
            }
            Commands::StatsP { input } => {
                let graph = Graph::<K>::load_from_binary(path_graph).unwrap();
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                let mut length_r = Vec::new();
                let mut length_sp = Vec::new();
                let mut length_nn = 0;

                // go to the first '>'
                input_reader.skip_until(b'>').unwrap();
                let mut current_header = String::new();
                while input_reader.read_line(&mut current_header).unwrap() > 0 {
                    // read the path
                    let mut buffer = Vec::new();
                    input_reader.read_until(b'>', &mut buffer).unwrap();
                    if buffer.last() == Some(&b'>') {
                        buffer.pop();
                    }
                    let current_path = String::from_utf8_lossy(&buffer);

                    // proccess the path
                    let path = MixedPath::from_string(&current_path, &graph).unwrap();
                    for ext in path.extensions {
                        match ext {
                            MyExtension::Repetition((nb_repeats, _offset)) => {
                                length_r.push(nb_repeats as usize);
                            }
                            MyExtension::ShortestPath(_target_node, length) => {
                                length_sp.push(length);
                            }
                            MyExtension::NextNode(_) => {
                                length_nn += 1;
                            }
                        }
                    }
                }
                // print the stats
                const NN_COST: usize = 2;
                const SP_COST: usize = 32;
                const R_COST: usize = 24;

                let total_nodes =
                    length_nn + length_sp.iter().sum::<usize>() + length_r.iter().sum::<usize>();
                let total_cost =
                    NN_COST * length_nn + SP_COST * length_sp.len() + R_COST * length_r.len();

                eprintln!("\n       Method | Number of encoded nodes | Memory cost");
                eprintln!("--------------|-------------------------|-----------------");
                eprintln!(
                    "    Next node | {:>14}  ({:.1}%) | {:>11} bits ({:.1}%)",
                    format_int(length_nn),
                    length_nn as f64 / total_nodes as f64 * 100.0,
                    format_int(2 * length_nn),
                    (NN_COST * length_nn) as f64 / total_cost as f64 * 100.0
                );
                eprintln!(
                    "Shortest path | {:>14}  ({:.1}%) | {:>11} bits ({:.1}%)",
                    format_int(length_sp.iter().sum::<usize>()),
                    length_sp.iter().sum::<usize>() as f64 / total_nodes as f64 * 100.0,
                    format_int(32 * length_sp.len()),
                    (SP_COST * length_sp.len()) as f64 / total_cost as f64 * 100.0
                );
                eprintln!(
                    "   Repetition | {:>14}  ({:.1}%) | {:>11} bits ({:.1}%)",
                    format_int(length_r.iter().sum::<usize>()),
                    length_r.iter().sum::<usize>() as f64 / total_nodes as f64 * 100.0,
                    format_int(24 * length_r.len()),
                    (R_COST * length_r.len()) as f64 / total_cost as f64 * 100.0
                );
                eprintln!(
                    "        Total | {:>14}  (100%)  | {:>11} bits (100%)",
                    format_int(total_nodes),
                    format_int(total_cost),
                );

                // plot the histogramm of length_sp and length_r
                // make_histo(
                //     length_sp,
                //     "test_sp",
                //     Some(0),
                //     Some(MAX_PATH_LENGTH + 1),
                //     None,
                // )
                // .unwrap();
                // make_histo(length_r, "test_r", None, Some(400), None).unwrap();
            }
        }
    }
}

// Helper function to format numbers with commas
fn format_int(n: usize) -> String {
    let s = n.to_string();
    let mut result = String::new();
    let mut chars = s.chars().rev().peekable();

    while let Some(c) = chars.next() {
        result.push(c);
        if chars.peek().is_some() && result.len() % 4 == 3 {
            result.push(',');
        }
    }

    result.chars().rev().collect()
}

#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
struct MyKmerSize<const K: usize>;
impl<const K: usize> kmer::KmerSize for MyKmerSize<K> {
    fn K() -> usize {
        K
    }
}

pub fn main() {
    let cli = Cli::parse();
    let k_size = cli.k_size;
    let path_graph = cli.graph;
    let command = &cli.command;

    // macro to define the generic type Kmer, whih is known only at compile time
    macro_rules! kmer_size_match {
        ($($($n:expr)+ => $tp:ty$(,)?)+) => {
            match k_size {
                $($(
                    $n => {
                        type KmerSize = MyKmerSize<$n>;
                        type Kmer = kmer::VarIntKmer<$tp, KmerSize>;
                        command.run::<Kmer>(&path_graph);
                    },
                )+)+
                _ => unimplemented!()
            }
        };
    }
    // without generic constants, we have to match kmer_size one by one
    // this is uggly and dramatically increases compilation time
    // The only workaround would be to modify the debruijn crate
    kmer_size_match!(
        1 2 3 4 => u8,
        5 6 7 8 => u16,
        9 10 11 12 13 14 15 16 => u32,
        17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 => u64,
        // ...
    );
}
