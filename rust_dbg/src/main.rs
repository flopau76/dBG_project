use rust_dbg::encoder::{Encoder, EncoderParams, Scaffold};
use rust_dbg::BaseGraph;

use needletail::parse_fastx_file;

use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::path::PathBuf;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a graph from a file of unitigs (as generated by ggcat)
    Build {
        /// K-mer size
        #[arg(short)]
        k: usize,

        /// Path to the unitigs file
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the resulting graph
        #[arg(short, long)]
        output: PathBuf,

        /// Treat reverse complementary kmers as different
        #[arg(short, long, default_value_t = false)]
        forward_only: bool,
    },
    /// Print some stats about a graph
    StatsG {
        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
    /// Encode a continuous sequence into a path in the graph
    Encode {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,

        /// Min repetition length to be used
        #[arg(long, default_value_t = 10)]
        min_rep: usize,

        /// Min length for shortest path
        #[arg(long, default_value_t = 10)]
        min_depth: usize,

        /// Max depth in Djikistra algorithm for shortest path
        #[arg(long, default_value_t = 100)]
        max_depth: usize,
    },
    /// Decode a path in the graph to retrieve the original sequence
    Decode {
        /// Path to the encoded paths
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (reconstructed sequence in fasta format)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
    /// Print some stats about the encoding of a path
    StatsP {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
}

macro_rules! run_with_ks {
    ($k:expr, $code:expr) => {{
        match $k {
            1..=4 => {
                type KS = u8;
                $code
            }
            5..=8 => {
                type KS = u16;
                $code
            }
            9..=16 => {
                type KS = u32;
                $code
            }
            17..=32 => {
                type KS = u64;
                $code
            }
            33..=64 => {
                type KS = u128;
                $code
            }
            _ => unimplemented!("K-mer size {} is not supported", $k),
        }
    }};
}

impl Commands {
    fn run(&self) {
        match self {
            Commands::Build {
                k,
                input,
                output,
                forward_only,
            } => {
                println!(
                    "Creating graph from unitig file: {} with k = {}, stranded = {}...",
                    input.display(),
                    k,
                    forward_only,
                );
                let base = BaseGraph::from_unitig_file(input, *k, *forward_only);
                base.save_to_binary(output).unwrap();
                println!("Graph saved to: {}", output.display());
            }
            Commands::StatsG { graph } => {
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    graph.print_stats();
                });
            }
            Commands::Encode {
                input,
                output,
                graph,
                min_rep,
                min_depth,
                max_depth,
            } => {
                let mut input_reader = parse_fastx_file(input).unwrap();
                let mut output_writer = BufWriter::new(File::create(output).unwrap());

                let encoder_params = EncoderParams {
                    min_nb_repeats: *min_rep as u16,
                    min_sp_length: *min_depth,
                    max_sp_length: *max_depth,
                    max_offset: 255,
                };

                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    let encoder = Encoder {
                        params: encoder_params,
                        graph: &graph,
                    };

                    while let Some(record) = input_reader.next() {
                        let record = record.unwrap();
                        let id = unsafe { String::from_utf8_unchecked(record.id().to_owned()) };
                        let seq = record.seq();
                        eprintln!("Encoding record {}", id);
                        println!(">{}", id);
                        let scaffold = encoder.encode_record(id, &seq).unwrap();
                        bincode::encode_into_std_write(
                            scaffold,
                            &mut output_writer,
                            bincode::config::standard(),
                        )
                        .unwrap();
                    }
                });
            }
            Commands::Decode {
                input,
                output,
                graph,
            } => {
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                let mut output_writer = BufWriter::new(File::create(output).unwrap());

                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    while let Ok(scaffold) = bincode::decode_from_std_read::<Scaffold, _, _>(
                        &mut input_reader,
                        bincode::config::standard(),
                    ) {
                        let header = format!(">{}\n", scaffold.id);
                        let seq = scaffold.sequence(&graph);
                        output_writer.write_all(header.as_bytes()).unwrap();
                        output_writer.write_all(seq.as_bytes()).unwrap();
                        output_writer.write_all(b"\n").unwrap();
                        eprintln!("Decoded scaffold: {}", scaffold.id);
                    }
                    eprintln!(
                        "Decoding completed. Output written to: {}",
                        output.display()
                    );
                });
            }
            Commands::StatsP { input, graph } => {
                let mut input_reader = BufReader::new(File::open(input).unwrap());

                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    while let Ok(scaffold) = bincode::decode_from_std_read::<Scaffold, _, _>(
                        &mut input_reader,
                        bincode::config::standard(),
                    ) {
                        scaffold.print_stats(&graph);
                    }
                });
            }
        }
    }
}

pub fn main() {
    let cli = Cli::parse();
    let command = &cli.command;
    command.run();
}
