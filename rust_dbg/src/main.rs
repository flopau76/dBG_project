use epserde::prelude::*;
use rust_dbg::encoder::{Encoder, EncoderParams, Scaffold};
use rust_dbg::{Graph, KmerStorage};

use needletail::parse_fastx_file;

use std::fs::File;
use std::io::{BufReader, BufWriter, Write};
use std::path::PathBuf;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// K-mer size
    #[arg(short)]
    k_size: usize,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a graph from a file of unitigs (as generated by ggcat)
    Build {
        /// Path to the unitigs file
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the resulting graph
        #[arg(short, long)]
        output: PathBuf,

        /// Treat reverse complementary kmers as different
        #[arg(short, long, default_value_t = false)]
        forward_only: bool,
    },
    /// Print some stats about a graph
    StatsG {
        /// Path to the encoded graph
        #[arg(short, long)]
        input: PathBuf,
    },
    /// Encode a continuous sequence into a path in the graph
    Encode {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,

        /// Min repetition length to be used
        #[arg(long, default_value_t = 10)]
        min_rep: usize,

        /// Min length for shortest path
        #[arg(long, default_value_t = 10)]
        min_depth: usize,

        /// Max depth in Djikistra algorithm for shortest path
        #[arg(long, default_value_t = 100)]
        max_depth: usize,
    },
    /// Decode a path in the graph to retrieve the original sequence
    Decode {
        /// Path to the encoded paths
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (reconstructed sequence in fasta format)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
    /// Print some stats about the encoding of a path
    StatsP {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
}

impl Commands {
    fn run<KS: KmerStorage + Serialize + Deserialize>(&self, k: usize) {
        match self {
            Commands::Build {
                input,
                output,
                forward_only,
            } => {
                println!(
                    "Creating graph from unitig file: {} with k = {}, stranded = {}...",
                    input.display(),
                    k,
                    forward_only,
                );
                Graph::<KS>::build_to_binary(input, output, k, *forward_only).unwrap();
                println!("Graph saved to: {}", output.display());
            }
            Commands::StatsG { input } => {
                let graph = Graph::<KS>::load_from_binary(&input).unwrap();
                graph.print_stats();
            }
            Commands::Encode {
                input,
                output,
                graph,
                min_rep,
                min_depth,
                max_depth,
            } => {
                let graph = Graph::<KS>::load_from_binary(graph).unwrap();
                let mut input_reader = parse_fastx_file(input).unwrap();
                let mut output_writer = BufWriter::new(File::create(output).unwrap());

                let encoder_params = EncoderParams {
                    min_nb_repeats: *min_rep as u16,
                    min_sp_length: *min_depth,
                    max_sp_length: *max_depth,
                    max_offset: 255,
                };
                let encoder = Encoder {
                    params: encoder_params,
                    graph: &graph,
                };

                while let Some(record) = input_reader.next() {
                    let record = record.unwrap();
                    let id = unsafe { String::from_utf8_unchecked(record.id().to_owned()) };
                    let seq = record.seq();
                    eprintln!("Encoding record {}", id);
                    println!(">{}", id);
                    let scaffold = encoder.encode_record(id, &seq).unwrap();
                    bincode::encode_into_std_write(
                        scaffold,
                        &mut output_writer,
                        bincode::config::standard(),
                    )
                    .unwrap();
                }
            }
            Commands::Decode {
                input,
                output,
                graph,
            } => {
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                let mut output_writer = BufWriter::new(File::create(output).unwrap());
                let graph = Graph::<KS>::load_from_binary(graph).unwrap();
                while let Ok(scaffold) = bincode::decode_from_std_read::<Scaffold, _, _>(
                    &mut input_reader,
                    bincode::config::standard(),
                ) {
                    let header = format!(">{}\n", scaffold.id);
                    let seq = scaffold.sequence(&graph);
                    output_writer.write_all(header.as_bytes()).unwrap();
                    output_writer.write_all(seq.as_bytes()).unwrap();
                    output_writer.write_all(b"\n").unwrap();
                    eprintln!("Decoded scaffold: {}", scaffold.id);
                }
                eprintln!(
                    "Decoding completed. Output written to: {}",
                    output.display()
                );
            }
            Commands::StatsP { input, graph } => {
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                let graph = Graph::<KS>::load_from_binary(graph).unwrap();
                while let Ok(scaffold) = bincode::decode_from_std_read::<Scaffold, _, _>(
                    &mut input_reader,
                    bincode::config::standard(),
                ) {
                    scaffold.print_stats(&graph);
                }
            }
        }
    }
}

pub fn main() {
    let cli = Cli::parse();
    let k = cli.k_size;
    let command = &cli.command;

    match k {
        1..=4 => {
            type KS = u8;
            command.run::<KS>(k);
        }
        5..=8 => {
            type KS = u16;
            command.run::<KS>(k);
        }
        9..=16 => {
            type KS = u32;
            command.run::<KS>(k);
        }
        17..=32 => {
            type KS = u64;
            command.run::<KS>(k);
        }
        33..=64 => {
            type KS = u128;
            command.run::<KS>(k);
        }
        _ => unimplemented!("K-mer size {} is not supported", k),
    }
}
