use epserde::prelude::*;
use rust_dbg::encoder::{Encoder, EncoderParams};
use rust_dbg::{Graph, KmerStorage};

use needletail::parse_fastx_file;

use std::fs::File;
use std::io::{BufReader, Write};
use std::path::PathBuf;
use std::time::Instant;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// K-mer size
    #[arg(short)]
    k_size: usize,

    /// Path to the binary graph file
    #[arg(short, long)]
    graph: PathBuf,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a graph from a file of unitigs (as generated by ggcat)
    Build {
        /// Path to the unitigs file
        #[arg(short, long)]
        input: PathBuf,

        /// Treat reverse complementary kmers as different
        #[arg(short, long, default_value_t = false)]
        forward_only: bool,
    },
    /// Get some stats about a graph
    StatsG {},
    /// Encode a continuous sequence into a path in the graph
    Encode {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,

        /// Min repetition length to be used
        #[arg(long, default_value_t = 10)]
        min_rep: usize,

        /// Min length for shortest path
        #[arg(long, default_value_t = 10)]
        min_depth: usize,

        /// Max depth in Djikistra algorithm for shortest path
        #[arg(long, default_value_t = 100)]
        max_depth: usize,
    },
    /// Decode a path in the graph to retrieve the original sequence
    Decode {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (reconstructed sequence in fasta format)
        #[arg(short, long)]
        output: PathBuf,
    },
    /// Get some stats about the encoding of a path
    StatsP {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,
    },
}

impl Commands {
    fn run<KS: KmerStorage + Serialize + Deserialize>(&self, k: usize, path_graph: &PathBuf) {
        match self {
            Commands::Build {
                input,
                forward_only,
            } => {
                eprint!("Creating graph... ");
                std::io::stderr().flush().unwrap();
                let start = Instant::now();
                let graph = Graph::<KS>::from_unitig_file(input, k, *forward_only);
                let duration = start.elapsed();
                eprintln!("done in {:?}", duration);

                eprint!("Saving graph... ");
                std::io::stderr().flush().unwrap();
                let start = Instant::now();
                graph.save_to_binary(path_graph).unwrap();
                let duration = start.elapsed();
                eprintln!("done in {:?}", duration);
            }
            Commands::StatsG {} => {
                let graph = Graph::<KS>::load_from_binary(&path_graph).unwrap();
                // graph.print_stats();
            }
            Commands::Encode {
                input,
                output,
                min_rep,
                min_depth,
                max_depth,
            } => {
                let graph = Graph::<KS>::load_from_binary(path_graph).unwrap();
                let mut input_reader = parse_fastx_file(input).unwrap();
                let mut output_writer = File::create(output).unwrap();

                let encoder_params = EncoderParams {
                    min_nb_repeats: *min_rep as u16,
                    min_sp_length: *min_depth,
                    max_sp_length: *max_depth,
                    max_offset: 255,
                };
                let encoder = Encoder {
                    params: encoder_params,
                    graph: &graph,
                };

                while let Some(record) = input_reader.next() {
                    let record = record.unwrap();
                    let id = unsafe { String::from_utf8_unchecked(record.id().to_owned()) };
                    let seq = record.seq();
                    eprintln!("Encoding record {}", id);
                    println!(">{}", id);
                    let scaffold = encoder.encode_record(id, &seq).unwrap();
                    todo!();
                }
            }
            Commands::Decode { input, output } => {
                todo!();
            }
            Commands::StatsP { input } => {
                let mut input_reader = BufReader::new(File::open(input).unwrap());
                todo!();
            }
        }
    }
}

pub fn main() {
    let cli = Cli::parse();
    let k = cli.k_size;
    let path_graph = cli.graph;
    let command = &cli.command;

    match k {
        1..=4 => {
            type KS = u8;
            command.run::<KS>(k, &path_graph);
        }
        5..=8 => {
            type KS = u16;
            command.run::<KS>(k, &path_graph);
        }
        9..=16 => {
            type KS = u32;
            command.run::<KS>(k, &path_graph);
        }
        17..=32 => {
            type KS = u64;
            command.run::<KS>(k, &path_graph);
        }
        33..=64 => {
            type KS = u128;
            command.run::<KS>(k, &path_graph);
        }
        _ => unimplemented!(),
    }
}
