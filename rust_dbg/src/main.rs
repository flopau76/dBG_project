use rust_dbg::encoder::{Encoder, GnomeEncoder, GreedyEncoder};
use rust_dbg::BaseGraph;

use std::path::PathBuf;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Create a graph from a file of unitigs (as generated by ggcat)
    Build {
        /// K-mer size
        #[arg(short)]
        k: usize,

        /// Path to the unitigs file
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the resulting graph
        #[arg(short, long)]
        output: PathBuf,

        /// Treat reverse complementary kmers as different
        #[arg(short, long, default_value_t = false)]
        forward_only: bool,
    },
    /// Print some stats about a graph
    StatsG {
        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
    /// Encode a continuous sequence into a path in the graph
    Encode {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,

        /// Min repetition length to be used
        #[arg(long, default_value_t = 10)]
        min_rep: usize,

        /// Min length for shortest path
        #[arg(long, default_value_t = 10)]
        min_depth: usize,

        /// Max depth in Djikistra algorithm for shortest path
        #[arg(long, default_value_t = 100)]
        max_depth: usize,
    },
    /// Encode a continuous sequence into a path in the graph
    EncodeTest {
        /// Path to the sequence file (fasta format)
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (custom text file)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,

        /// Size of the g-node-mer
        #[arg(long, default_value_t = 10)]
        gg: usize,
    },
    /// Decode a path in the graph to retrieve the original sequence
    Decode {
        /// Path to the encoded paths
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the output file (reconstructed sequence in fasta format)
        #[arg(short, long)]
        output: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
    /// Print some stats about the encoding of a path
    StatsP {
        /// Path to the file containing the encoded path
        #[arg(short, long)]
        input: PathBuf,

        /// Path to the encoded graph
        #[arg(short, long)]
        graph: PathBuf,
    },
}

macro_rules! run_with_ks {
    ($k:expr, $code:expr) => {{
        let _ = match $k {
            1..=4 => {
                type KS = u8;
                $code
            }
            5..=8 => {
                type KS = u16;
                $code
            }
            9..=16 => {
                type KS = u32;
                $code
            }
            17..=32 => {
                type KS = u64;
                $code
            }
            33..=64 => {
                type KS = u128;
                $code
            }
            _ => unimplemented!("K-mer size {} is not supported", $k),
        };
    }};
}

impl Commands {
    fn run(&self) {
        match self {
            Commands::Build {
                k,
                input,
                output,
                forward_only,
            } => {
                println!(
                    "Creating graph from unitig file: {} with k = {}, stranded = {}...",
                    input.display(),
                    k,
                    forward_only,
                );
                let base = BaseGraph::from_unitig_file(input, *k, *forward_only);
                base.save_to_binary(output).unwrap();
                println!("Graph saved to: {}", output.display());
            }
            Commands::StatsG { graph } => {
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    graph.print_stats();
                });
            }
            Commands::Encode {
                input,
                output,
                graph,
                min_rep,
                min_depth,
                max_depth,
            } => {
                let encoder = GreedyEncoder {
                    min_nb_repeats: *min_rep as u16,
                    min_sp_length: *min_depth,
                    max_sp_length: *max_depth,
                    max_offset: 255,
                };
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    encoder.encode_from_fasta(input, output, &graph)
                });
            }
            Commands::EncodeTest {
                input,
                output,
                graph,
                gg,
            } => {
                let mut encoder = GnomeEncoder::new(*gg);
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    encoder.encode_from_fasta(input, output, &graph)
                });
            }
            Commands::Decode {
                input,
                output,
                graph,
            } => {
                let encoder = GreedyEncoder::default();
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    encoder.decode_to_fasta(input, output, &graph).unwrap();
                });
            }
            Commands::StatsP { input, graph } => {
                let encoder = GreedyEncoder::default();
                let base = BaseGraph::load_from_binary(&graph).unwrap();
                run_with_ks!(base.k(), {
                    let graph = base.finish::<KS>();
                    encoder.print_stats(input, &graph).unwrap();
                });
            }
        }
    }
}

pub fn main() {
    let cli = Cli::parse();
    let command = &cli.command;
    command.run();
}
