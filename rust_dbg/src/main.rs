use rust_dbg::fasta_reader;
use rust_dbg::path::NodeIterator;
use rust_dbg::{fasta_reader::FastaReader, graph::Graph, path, stats};

use debruijn::{kmer, Dir, Kmer};
use debruijn::dna_string::DnaString;

use regex::Regex;

use std::fs::File;
use std::io::{BufWriter, BufReader, BufRead, Write};

use serde::{Serialize, Deserialize};
use bincode::serde::{encode_into_std_write, decode_from_std_read};

use std::time::Instant;

fn main() {
    // input/output files
    let path_graph = "../data/output/chr1/AalbF5_k31.fna";
    let path_bin = "../data/output/chr1/AalbF5_k31.bin";
    let path_fasta = "../data/input/chr1/AalbF5_splitN.fna";
    let path_checkpoints = "../data/output/chr1/checkpoints_double_AalbF5_in1.fna";
    let path_reconstruct = "../data/output/chr1/reconstruct_nodes.AalbF5.fna";

    // params used for kmer construction by ggcat
    let stranded = false;
    type Kmer31 = kmer::VarIntKmer<u64, kmer::K31>;

    // let graph = make_graph::<Kmer31>(path_graph, stranded);
    // save_graph(&graph, path_bin);
    let graph = load_graph::<Kmer31>(path_bin);
    let haplo = FastaReader::new(path_fasta).unwrap();

    // stats::stats_graph(&graph);
    stats::stats_haplo(&graph, haplo);

    // get_checkpoints(&graph, path_fasta);
    reconstruct_fasta(&graph, path_checkpoints, path_reconstruct);
    // stats_draft::<Kmer31>(&graph, path_checkpoints, path_fasta);
}

/// Create a graph from a unitigs file.
pub fn make_graph<K: Kmer + Send + Sync>(path_graph: &str, stranded: bool) -> Graph<K> {
    eprint!("Creating graph (parallel)... ");
    std::io::stderr().flush().unwrap();
    let start = Instant::now();

    let graph = Graph::from_unitigs(path_graph, stranded);

    let duration = start.elapsed();
    eprintln!("done in {:?}", duration);

    graph
}

/// Save a graph to a binary file.
pub fn save_graph<K: Kmer + Serialize>(graph: &Graph<K>, path_bin: &str) {
    eprint!("Saving graph... ");
    std::io::stderr().flush().unwrap();
    let start = Instant::now();

    let mut f = BufWriter::new(File::create(path_bin).unwrap());
    let config = bincode::config::standard();
    let _ = encode_into_std_write(graph, &mut f, config).unwrap();

    let duration = start.elapsed();
    eprintln!("done in {:?}", duration);
}

/// Load a graph from a binary file.
pub fn load_graph<K: Kmer + for<'a> Deserialize<'a>>(path_bin: &str) -> Graph<K> {
    eprint!("Loading graph... ");
    std::io::stderr().flush().unwrap();
    let start = Instant::now();

    let mut f = BufReader::new(File::open(path_bin).unwrap());
    let config = bincode::config::standard();
    let graph = decode_from_std_read(&mut f, config).unwrap();

    let duration = start.elapsed();
    eprintln!("done in {:?}", duration);

    graph
}

/// Decompose the records in a fasta file into a suite a nodes in the graph.
/// Result is writen directly to stdout.
fn get_checkpoints<K: Kmer>(graph: &Graph<K>, path_fasta: &str) {
    let fasta_reader = FastaReader::new(path_fasta).unwrap();

    for record in fasta_reader {
        // dividing the record into chunks
        eprintln!("Processing record: {}", record.header());
        println!(">{}", record.header());
        let start = Instant::now();
        let path = path::get_checkpoints_bfs(&graph, &record).unwrap();
        let duration = start.elapsed();
        eprintln!("  - divided record into {} chunks\n  - time elapsed: {:?}", path.len(), duration);
    }
}

/// Reconstruct the records from the file generated by `get_checkpoints`.
// TODO: the reconstruction is not exact. Why ?!
fn reconstruct_fasta<K: Kmer>(graph: &Graph<K>, file_chunks: &str, file_res: &str) {

    let file_chunks = BufReader::new(File::open(file_chunks).unwrap());
    let mut file_res = BufWriter::new(File::create(file_res).unwrap());
    let mut path = DnaString::new();

    for line in file_chunks.lines() {
        let line = line.unwrap();
        if line.starts_with('>') {
            if !path.is_empty() { 
                writeln!(file_res, "{}", path.suffix(K::k()-1).to_string()).unwrap();
            }
            eprintln!("Processing record: {}", line);
            writeln!(file_res, "{}", line).unwrap();
            continue;
        }
        // parse the checkpoints to get the start and end nodes
        let pattern = r"(\d+) unitigs, starting at (\d+):\s+\((\d+), (Left|Right)\)\s+\((\d+), (Left|Right)\)";
        let re = Regex::new(pattern).unwrap();
        let caps = re.captures(&line).unwrap();
        let start_id = caps[3].parse::<usize>().unwrap();
        let start_dir = if &caps[4] == "Left" { Dir::Left } else { Dir::Right };
        let end_id = caps[5].parse::<usize>().unwrap();
        let end_dir = if &caps[6] == "Left" { Dir::Left } else { Dir::Right };

        // get the path between the start and end nodes
        path = path::get_shortest_path_bfs(graph, (start_id, start_dir), (end_id, end_dir)).unwrap();
        write!(file_res, "{}", path.prefix(path.len()-K::k()+1).to_string()).unwrap();
    }
    writeln!(file_res, "{}", path.suffix(K::k()-1).to_string()).unwrap();
}

// reads the output generated by the `get_checkpoints` function and gets some stats per checkpoints (nb of unitigs, nucleotides, breakpoints)
fn stats_draft<K: Kmer>(graph: &Graph<K>, path_checkpoints: &str, path_fasta: &str) {
    todo!();

    // read the checkpoints file
    let checkpoint_f = BufReader::new(File::open(path_checkpoints).unwrap());
    let mut checkpoints = Vec::new();
    let mut current_checkpoints = Vec::new();
    for line in checkpoint_f.lines() {
        let line = line.unwrap();
        if line.starts_with('>') {
            // save the previous record and create a new one
            if !current_checkpoints.is_empty() {
                checkpoints.push(current_checkpoints);
                current_checkpoints = Vec::new();
            }
            continue;
        }
        // parse the line to get the start node and the nb of unitigs in this path
        let mut parts = line.split(":").next().unwrap().split(" ");
        let nb_unitigs = parts.next().unwrap().parse::<usize>().unwrap();
        let start = parts.last().unwrap().parse::<usize>().unwrap();
        current_checkpoints.push((nb_unitigs, start));
    }

    // iterate over the fasta file
    let fasta_reader = FastaReader::new(path_fasta).unwrap();
    for (i, record) in fasta_reader.enumerate() {
        let seq = record.dna_string();
        let mut node_iter = NodeIterator::new(graph, &seq);

        for checkpoint in checkpoints[i].iter() {
            let nb_unitigs = checkpoint.0;
            let start = checkpoint.1;

            println!("Position iter: {}\t Position checkpoints {}", node_iter.position(), start);
            // assert_eq!(start, node_iter.position(), "Mismatch in position");
            for _ in 0..nb_unitigs {
                let (node_id, dir) = node_iter.next().unwrap().expect("more nodes in path than expected");
            }
        }
        break;
    }
}